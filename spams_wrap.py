# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

"""
This module gives access to some functions of the spams C++ library.
The functions defined here should not be called directly.
Use of spams functions should only be done through module spams.
"""

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_spams_wrap', [dirname(__file__)])
        except ImportError:
            import _spams_wrap
            return _spams_wrap
        if fp is not None:
            try:
                _mod = imp.load_module('_spams_wrap', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _spams_wrap = swig_import_helper()
    del swig_import_helper
else:
    import _spams_wrap
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def m_ones(*args):
  return _spams_wrap.m_ones(*args)
m_ones = _spams_wrap.m_ones

def skip_space(*args):
  return _spams_wrap.skip_space(*args)
skip_space = _spams_wrap.skip_space

def parse_line(*args):
  return _spams_wrap.parse_line(*args)
parse_line = _spams_wrap.parse_line

def intlist(*args):
  return _spams_wrap.intlist(*args)
intlist = _spams_wrap.intlist
L1COEFFS = _spams_wrap.L1COEFFS
L2ERROR = _spams_wrap.L2ERROR
PENALTY = _spams_wrap.PENALTY
SPARSITY = _spams_wrap.SPARSITY
L2ERROR2 = _spams_wrap.L2ERROR2
PENALTY2 = _spams_wrap.PENALTY2
FISTAMODE = _spams_wrap.FISTAMODE
L2 = _spams_wrap.L2
L1L2 = _spams_wrap.L1L2
L1L2FL = _spams_wrap.L1L2FL
L1L2MU = _spams_wrap.L1L2MU

def simpleGroupTree(*args):
  """simpleGroupTree(int degr) -> std::vector<(p.StructNodeElem<(double)>)>"""
  return _spams_wrap.simpleGroupTree(*args)

def readGroupStruct(*args):
  """readGroupStruct(char file) -> std::vector<(p.StructNodeElem<(double)>)>"""
  return _spams_wrap.readGroupStruct(*args)

def groupStructOfString(*args):
  """groupStructOfString(char data) -> std::vector<(p.StructNodeElem<(double)>)>"""
  return _spams_wrap.groupStructOfString(*args)


def sort(*args):
  """
    sort(Vector<(double)> v, bool mode)
    sort(Vector<(float)> v, bool mode)
    """
  return _spams_wrap.sort(*args)

def mult(*args):
  """
    mult(Matrix<(double)> X, Matrix<(double)> Y, Matrix<(double)> XY, 
        bool transX, bool transY, double a, 
        double b)
    mult(Matrix<(float)> X, Matrix<(float)> Y, Matrix<(float)> XY, 
        bool transX, bool transY, float a, float b)
    """
  return _spams_wrap.mult(*args)

def AAt(*args):
  """
    AAt(SpMatrix<(double)> A, Matrix<(double)> B)
    AAt(SpMatrix<(float)> A, Matrix<(float)> B)
    """
  return _spams_wrap.AAt(*args)

def XAt(*args):
  """
    XAt(SpMatrix<(double)> A, Matrix<(double)> X, Matrix<(double)> XAt)
    XAt(SpMatrix<(float)> A, Matrix<(float)> X, Matrix<(float)> XAt)
    """
  return _spams_wrap.XAt(*args)

def applyBayerPattern(*args):
  """
    applyBayerPattern(Vector<(double)> v, int offset)
    applyBayerPattern(Vector<(float)> v, int offset)
    """
  return _spams_wrap.applyBayerPattern(*args)

def conjugateGradient(*args):
  """
    conjugateGradient(Matrix<(double)> A, Vector<(double)> b, Vector<(double)> x, 
        double tol, int itermax)
    conjugateGradient(Matrix<(float)> A, Vector<(float)> b, Vector<(float)> x, 
        float tol, int itermax)
    """
  return _spams_wrap.conjugateGradient(*args)

def invSym(*args):
  """
    invSym(Matrix<(double)> A)
    invSym(Matrix<(float)> A)
    """
  return _spams_wrap.invSym(*args)

def normalize(*args):
  """
    normalize(Matrix<(double)> A)
    normalize(Matrix<(float)> A)
    """
  return _spams_wrap.normalize(*args)

def sparseProject(*args):
  """
    sparseProject(Matrix<(double)> U, Matrix<(double)> V, double thrs, 
        int mode, double lambda1, double lambda2, double lambda3, 
        bool pos, int numThreads)
    sparseProject(Matrix<(float)> U, Matrix<(float)> V, float thrs, int mode, 
        float lambda1, float lambda2, float lambda3, 
        bool pos, int numThreads)
    """
  return _spams_wrap.sparseProject(*args)

def lassoD(*args):
  """
    lassoD(Matrix<(double)> X, Matrix<(double)> D, bool return_reg_path, 
        int L, double constraint, double lambda2, 
        constraint_type mode, bool pos, bool ols, 
        int numThreads, int max_length_path, bool verbose, 
        bool cholevsky) -> SpMatrix<(double)>
    lassoD(Matrix<(float)> X, Matrix<(float)> D, bool return_reg_path, 
        int L, float constraint, float lambda2, 
        constraint_type mode, bool pos, bool ols, 
        int numThreads, int max_length_path, bool verbose, 
        bool cholevsky) -> SpMatrix<(float)>
    """
  return _spams_wrap.lassoD(*args)

def lassoQq(*args):
  """
    lassoQq(Matrix<(double)> X, Matrix<(double)> Q, Matrix<(double)> q, 
        bool return_reg_path, int L, double constraint, 
        double lambda2, constraint_type mode, 
        bool pos, bool ols, int numThreads, int max_length_path, 
        bool verbose, bool cholevsky) -> SpMatrix<(double)>
    lassoQq(Matrix<(float)> X, Matrix<(float)> Q, Matrix<(float)> q, 
        bool return_reg_path, int L, float constraint, 
        float lambda2, constraint_type mode, 
        bool pos, bool ols, int numThreads, int max_length_path, 
        bool verbose, bool cholevsky) -> SpMatrix<(float)>
    """
  return _spams_wrap.lassoQq(*args)

def lassoMask(*args):
  """
    lassoMask(Matrix<(double)> X, Matrix<(double)> D, Matrix<(bool)> B, 
        int L, double constraint, double lambda2, 
        constraint_type mode, bool pos, int numThreads, 
        bool verbose) -> SpMatrix<(double)>
    lassoMask(Matrix<(float)> X, Matrix<(float)> D, Matrix<(bool)> B, 
        int L, float constraint, float lambda2, 
        constraint_type mode, bool pos, int numThreads, 
        bool verbose) -> SpMatrix<(float)>
    """
  return _spams_wrap.lassoMask(*args)

def lassoWeighted(*args):
  """
    lassoWeighted(Matrix<(double)> X, Matrix<(double)> D, Matrix<(double)> W, 
        int L, double constraint, constraint_type mode, 
        bool pos, int numThreads, bool verbose) -> SpMatrix<(double)>
    lassoWeighted(Matrix<(float)> X, Matrix<(float)> D, Matrix<(float)> W, 
        int L, float constraint, constraint_type mode, 
        bool pos, int numThreads, bool verbose) -> SpMatrix<(float)>
    """
  return _spams_wrap.lassoWeighted(*args)

def omp(*args):
  """
    omp(Matrix<(double)> X, Matrix<(double)> D, bool return_reg_path, 
        bool given_L, Vector<(int)> L, bool given_eps, 
        Vector<(double)> eps, bool given_Lambda, 
        Vector<(double)> Lambda, int numThreads) -> SpMatrix<(double)>
    omp(Matrix<(float)> X, Matrix<(float)> D, bool return_reg_path, 
        bool given_L, Vector<(int)> L, bool given_eps, 
        Vector<(float)> eps, bool given_Lambda, 
        Vector<(float)> Lambda, int numThreads) -> SpMatrix<(float)>
    """
  return _spams_wrap.omp(*args)

def ompMask(*args):
  """
    ompMask(Matrix<(double)> X, Matrix<(double)> D, Matrix<(bool)> B, 
        bool return_reg_path, bool given_L, Vector<(int)> L, 
        bool given_eps, Vector<(double)> eps, 
        bool given_Lambda, Vector<(double)> Lambda, 
        int numThreads) -> SpMatrix<(double)>
    ompMask(Matrix<(float)> X, Matrix<(float)> D, Matrix<(bool)> B, 
        bool return_reg_path, bool given_L, Vector<(int)> L, 
        bool given_eps, Vector<(float)> eps, 
        bool given_Lambda, Vector<(float)> Lambda, 
        int numThreads) -> SpMatrix<(float)>
    """
  return _spams_wrap.ompMask(*args)

def somp(*args):
  """
    somp(Matrix<(double)> X, Matrix<(double)> D, Vector<(int)> groups, 
        int LL, double eps, int numThreads) -> SpMatrix<(double)>
    somp(Matrix<(float)> X, Matrix<(float)> D, Vector<(int)> groups, 
        int LL, float eps, int numThreads) -> SpMatrix<(float)>
    """
  return _spams_wrap.somp(*args)

def cd(*args):
  """
    cd(Matrix<(double)> X, Matrix<(double)> D, SpMatrix<(double)> alpha, 
        double lambda1, constraint_type mode, 
        int itermax, double tol, int numThreads) -> SpMatrix<(double)>
    cd(Matrix<(float)> X, Matrix<(float)> D, SpMatrix<(float)> alpha, 
        float lambda1, constraint_type mode, 
        int itermax, float tol, int numThreads) -> SpMatrix<(float)>
    """
  return _spams_wrap.cd(*args)

def l1L2BCD(*args):
  """
    l1L2BCD(Matrix<(double)> X, Matrix<(double)> D, Matrix<(double)> alpha0, 
        Vector<(int)> groups, double lambda1, 
        constraint_type mode, int itermax, double tol, 
        int numThreads)
    l1L2BCD(Matrix<(float)> X, Matrix<(float)> D, Matrix<(float)> alpha0, 
        Vector<(int)> groups, float lambda1, 
        constraint_type mode, int itermax, float tol, 
        int numThreads)
    """
  return _spams_wrap.l1L2BCD(*args)

def alltrainDL(*args):
  """
    alltrainDL(Data<(double)> X, bool in_memory, bool return_model, 
        Matrix<(double)> m_A, Matrix<(double)> m_B, 
        int m_iter, Matrix<(double)> D1, Vector<(double)> eta_g, 
        SpMatrix<(bool)> groups, SpMatrix<(bool)> groups_var, 
        Vector<(int)> own_variables, 
        Vector<(int)> N_own_variables, int num_threads, 
        double tol, bool fixed_step, bool ista, 
        int batch_size, int K, double lambda1, double lambda2, 
        double lambda3, int iter, double t0, 
        constraint_type mode, char name_regul, 
        bool posAlpha, bool posD, bool expand, constraint_type_D modeD, 
        bool whiten, bool clean, bool verbose, 
        double gamma1, double gamma2, double rho, 
        int iter_updateD, bool stochastic, 
        int modeParam, bool batch, bool log, char logName) -> Matrix<(double)>
    alltrainDL(Data<(float)> X, bool in_memory, bool return_model, 
        Matrix<(float)> m_A, Matrix<(float)> m_B, int m_iter, 
        Matrix<(float)> D1, Vector<(float)> eta_g, 
        SpMatrix<(bool)> groups, SpMatrix<(bool)> groups_var, 
        Vector<(int)> own_variables, 
        Vector<(int)> N_own_variables, int num_threads, 
        float tol, bool fixed_step, bool ista, int batch_size, 
        int K, double lambda1, double lambda2, 
        double lambda3, int iter, double t0, 
        constraint_type mode, char name_regul, bool posAlpha, 
        bool posD, bool expand, constraint_type_D modeD, 
        bool whiten, bool clean, bool verbose, 
        double gamma1, double gamma2, float rho, 
        int iter_updateD, bool stochastic, int modeParam, 
        bool batch, bool log, char logName) -> Matrix<(float)>
    """
  return _spams_wrap.alltrainDL(*args)

def archetypalAnalysis(*args):
  """
    archetypalAnalysis(Matrix<(double)> X, int p, bool robust, double epsilon, 
        bool computeXtX, int stepsFISTA, int stepsAS, 
        bool randominit, int numThreads) -> Matrix<(double)>
    archetypalAnalysis(Matrix<(float)> X, int p, bool robust, float epsilon, 
        bool computeXtX, int stepsFISTA, int stepsAS, 
        bool randominit, int numThreads) -> Matrix<(float)>
    """
  return _spams_wrap.archetypalAnalysis(*args)

def archetypalAnalysisInit(*args):
  """
    archetypalAnalysisInit(Matrix<(double)> X, Matrix<(double)> Z0, bool robust, 
        double epsilon, bool computeXtX, int stepsFISTA, 
        int stepsAS, int numThreads) -> Matrix<(double)>
    archetypalAnalysisInit(Matrix<(float)> X, Matrix<(float)> Z0, bool robust, 
        float epsilon, bool computeXtX, int stepsFISTA, 
        int stepsAS, int numThreads) -> Matrix<(float)>
    """
  return _spams_wrap.archetypalAnalysisInit(*args)

def decompSimplex(*args):
  """
    decompSimplex(Matrix<(double)> X, Matrix<(double)> Z, bool computeXtX, 
        int numThreads) -> SpMatrix<(double)>
    decompSimplex(Matrix<(float)> X, Matrix<(float)> Z, bool computeXtX, 
        int numThreads) -> SpMatrix<(float)>
    """
  return _spams_wrap.decompSimplex(*args)

def fistaFlat(*args):
  """
    fistaFlat(Matrix<(double)> X, AbstractMatrixB<(double)> D, Matrix<(double)> alpha0, 
        Matrix<(double)> alpha, 
        Vector<(int)> groups, int num_threads, int max_it, 
        double L0, bool fixed_step, double gamma, 
        double _lambda, double delta, double lambda2, 
        double lambda3, double a, double b, double c, 
        double tol, int it0, int max_iter_backtracking, 
        bool compute_gram, bool lin_admm, bool admm, 
        bool intercept, bool resetflow, char name_regul, 
        char name_loss, bool verbose, bool pos, 
        bool clever, bool log, bool ista, bool subgrad, 
        char logName, bool is_inner_weights, 
        Vector<(double)> inner_weights, int size_group, 
        bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix<(double)>
    fistaFlat(Matrix<(float)> X, AbstractMatrixB<(float)> D, Matrix<(float)> alpha0, 
        Matrix<(float)> alpha, Vector<(int)> groups, 
        int num_threads, int max_it, 
        float L0, bool fixed_step, float gamma, float _lambda, 
        float delta, float lambda2, float lambda3, 
        float a, float b, float c, float tol, 
        int it0, int max_iter_backtracking, bool compute_gram, 
        bool lin_admm, bool admm, bool intercept, 
        bool resetflow, char name_regul, 
        char name_loss, bool verbose, bool pos, bool clever, 
        bool log, bool ista, bool subgrad, char logName, 
        bool is_inner_weights, Vector<(float)> inner_weights, 
        int size_group, bool sqrt_step, 
        bool transpose, int linesearch_mode) -> Matrix<(float)>
    """
  return _spams_wrap.fistaFlat(*args)

def fistaTree(*args):
  """
    fistaTree(Matrix<(double)> X, AbstractMatrixB<(double)> D, Matrix<(double)> alpha0, 
        Matrix<(double)> alpha, 
        Vector<(double)> eta_g, SpMatrix<(bool)> groups, 
        Vector<(int)> own_variables, Vector<(int)> N_own_variables, 
        int num_threads, int max_it, 
        double L0, bool fixed_step, double gamma, 
        double _lambda, double delta, double lambda2, 
        double lambda3, double a, double b, double c, 
        double tol, int it0, int max_iter_backtracking, 
        bool compute_gram, bool lin_admm, bool admm, 
        bool intercept, bool resetflow, char name_regul, 
        char name_loss, bool verbose, bool pos, 
        bool clever, bool log, bool ista, bool subgrad, 
        char logName, bool is_inner_weights, 
        Vector<(double)> inner_weights, int size_group, 
        bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix<(double)>
    fistaTree(Matrix<(float)> X, AbstractMatrixB<(float)> D, Matrix<(float)> alpha0, 
        Matrix<(float)> alpha, Vector<(float)> eta_g, 
        SpMatrix<(bool)> groups, 
        Vector<(int)> own_variables, Vector<(int)> N_own_variables, 
        int num_threads, int max_it, 
        float L0, bool fixed_step, float gamma, float _lambda, 
        float delta, float lambda2, float lambda3, 
        float a, float b, float c, float tol, 
        int it0, int max_iter_backtracking, bool compute_gram, 
        bool lin_admm, bool admm, bool intercept, 
        bool resetflow, char name_regul, char name_loss, 
        bool verbose, bool pos, bool clever, 
        bool log, bool ista, bool subgrad, char logName, 
        bool is_inner_weights, Vector<(float)> inner_weights, 
        int size_group, bool sqrt_step, 
        bool transpose, int linesearch_mode) -> Matrix<(float)>
    """
  return _spams_wrap.fistaTree(*args)

def fistaGraph(*args):
  """
    fistaGraph(Matrix<(double)> X, AbstractMatrixB<(double)> D, Matrix<(double)> alpha0, 
        Matrix<(double)> alpha, 
        Vector<(double)> eta_g, SpMatrix<(bool)> groups, 
        SpMatrix<(bool)> groups_var, int num_threads, 
        int max_it, double L0, bool fixed_step, 
        double gamma, double _lambda, double delta, 
        double lambda2, double lambda3, double a, double b, 
        double c, double tol, int it0, int max_iter_backtracking, 
        bool compute_gram, bool lin_admm, 
        bool admm, bool intercept, bool resetflow, 
        char name_regul, char name_loss, bool verbose, 
        bool pos, bool clever, bool log, bool ista, 
        bool subgrad, char logName, bool is_inner_weights, 
        Vector<(double)> inner_weights, 
        int size_group, bool sqrt_step, bool transpose, 
        int linesearch_mode) -> Matrix<(double)>
    fistaGraph(Matrix<(float)> X, AbstractMatrixB<(float)> D, Matrix<(float)> alpha0, 
        Matrix<(float)> alpha, Vector<(float)> eta_g, 
        SpMatrix<(bool)> groups, 
        SpMatrix<(bool)> groups_var, int num_threads, 
        int max_it, float L0, bool fixed_step, float gamma, 
        float _lambda, float delta, float lambda2, 
        float lambda3, float a, float b, float c, 
        float tol, int it0, int max_iter_backtracking, 
        bool compute_gram, bool lin_admm, bool admm, 
        bool intercept, bool resetflow, char name_regul, 
        char name_loss, bool verbose, bool pos, 
        bool clever, bool log, bool ista, bool subgrad, 
        char logName, bool is_inner_weights, 
        Vector<(float)> inner_weights, int size_group, 
        bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix<(float)>
    """
  return _spams_wrap.fistaGraph(*args)

def proximalFlat(*args):
  """
    proximalFlat(Matrix<(double)> alpha0, Matrix<(double)> alpha, Vector<(int)> groups, 
        int num_threads, double lambda1, 
        double lambda2, double lambda3, bool intercept, 
        bool resetflow, char name_regul, bool verbose, 
        bool pos, bool clever, bool eval, 
        int size_group, bool transpose) -> Vector<(double)>
    proximalFlat(Matrix<(float)> alpha0, Matrix<(float)> alpha, Vector<(int)> groups, 
        int num_threads, float lambda1, 
        float lambda2, float lambda3, bool intercept, 
        bool resetflow, char name_regul, bool verbose, 
        bool pos, bool clever, bool eval, int size_group, 
        bool transpose) -> Vector<(float)>
    """
  return _spams_wrap.proximalFlat(*args)

def proximalTree(*args):
  """
    proximalTree(Matrix<(double)> alpha0, Matrix<(double)> alpha, Vector<(double)> eta_g, 
        SpMatrix<(bool)> groups, 
        Vector<(int)> own_variables, Vector<(int)> N_own_variables, 
        int num_threads, double lambda1, 
        double lambda2, double lambda3, bool intercept, 
        bool resetflow, char name_regul, bool verbose, 
        bool pos, bool clever, bool eval, int size_group, 
        bool transpose) -> Vector<(double)>
    proximalTree(Matrix<(float)> alpha0, Matrix<(float)> alpha, Vector<(float)> eta_g, 
        SpMatrix<(bool)> groups, Vector<(int)> own_variables, 
        Vector<(int)> N_own_variables, 
        int num_threads, float lambda1, 
        float lambda2, float lambda3, bool intercept, 
        bool resetflow, char name_regul, bool verbose, 
        bool pos, bool clever, bool eval, int size_group, 
        bool transpose) -> Vector<(float)>
    """
  return _spams_wrap.proximalTree(*args)

def proximalGraph(*args):
  """
    proximalGraph(Matrix<(double)> alpha0, Matrix<(double)> alpha, Vector<(double)> eta_g, 
        SpMatrix<(bool)> groups, 
        SpMatrix<(bool)> groups_var, int num_threads, 
        double lambda1, double lambda2, double lambda3, 
        bool intercept, bool resetflow, char name_regul, 
        bool verbose, bool pos, bool clever, 
        bool eval, int size_group, bool transpose) -> Vector<(double)>
    proximalGraph(Matrix<(float)> alpha0, Matrix<(float)> alpha, Vector<(float)> eta_g, 
        SpMatrix<(bool)> groups, SpMatrix<(bool)> groups_var, 
        int num_threads, 
        float lambda1, float lambda2, float lambda3, 
        bool intercept, bool resetflow, char name_regul, 
        bool verbose, bool pos, bool clever, bool eval, 
        int size_group, bool transpose) -> Vector<(float)>
    """
  return _spams_wrap.proximalGraph(*args)

def graphOfGroupStruct(*args):
  """
    graphOfGroupStruct(std::vector<(p.StructNodeElem<(double)>)> gstruct) -> Vector<(double)>
    graphOfGroupStruct(std::vector<(p.StructNodeElem<(float)>)> gstruct) -> Vector<(float)>
    """
  return _spams_wrap.graphOfGroupStruct(*args)

def treeOfGroupStruct(*args):
  """
    treeOfGroupStruct(std::vector<(p.StructNodeElem<(double)>)> gstruct) -> int
    treeOfGroupStruct(std::vector<(p.StructNodeElem<(float)>)> gstruct, Vector<(float)> peta_g) -> int
    """
  return _spams_wrap.treeOfGroupStruct(*args)

def im2col_sliding(*args):
  """
    im2col_sliding(Matrix<(double)> A, Matrix<(double)> B, int m, int n, 
        bool RGB)
    im2col_sliding(Matrix<(float)> A, Matrix<(float)> B, int m, int n, 
        bool RGB)
    """
  return _spams_wrap.im2col_sliding(*args)

